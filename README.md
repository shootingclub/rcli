# Rcli Demo
>
> cargo generate https://github.com/tyr-rust-bootcamp/template

## features
- [x] v1.1
> cargo run --  "Hello World" -c " config list " -dd csv -i ../assets/juventus.csv -o output.json
>
## lib.rs和mod.rs
在Rust编程语言中，`lib.rs`和`mod.rs`文件扮演着不同但互补的角色。它们都是用于组织代码和实现模块化的重要组件。

- **lib.rs**：`lib.rs`是Rust项目中库(crate)的根文件。每个Rust项目都会有一个`src/lib.rs`文件，它作为库级别的入口点，定义了库的公共接口。这个文件通常包含库级别的功能、结构体、枚举等，并且可以被其他模块所使用。如果一个Rust项目是一个库项目（即它被设计成被其他程序引用），那么它至少会有一个`src/lib.rs`文件。
- **mod.rs**：`mod.rs`文件通常用于将同一目录下的多个Rust文件（以`.rs`扩展名结尾）组合在一起，形成一个模块。这有助于更好地组织代码，使结构更加清晰。在`mod.rs`文件中，你可以包含模块级的私有函数、类型等，这些通常不会暴露给外部使用。此外，`mod.rs`可以控制模块内部项目的可见性，比如通过使用`pub`关键字来声明公共项。

综上所述，`lib.rs`是整个库的根文件，而`mod.rs`则用于组织特定目录下的模块。在大型项目中，合理使用这两种文件可以帮助开发者更好地管理和组织代码，提高代码的可读性和可维护性。

## 为什么实现相同trait 的不同实现类 无法推导向上 而是使用 Box::new
在 Rust 中，实现相同 trait 的不同类型确实无法直接向上推导为 trait 的动态派发版本（`dyn Trait`），原因在于 Rust 的静态类型系统和所有权模型。

1. **静态类型系统**：Rust 的类型系统在编译时需要知道所有类型信息，这意味着 Rust 通常不能像动态类型语言那样在运行时改变类型。因此，当你有一个 `dyn Trait` 类型的值时，它实际上是一个指向堆上某个具体类型的指针，这个具体类型在编译时是未知的，但实现了对应的 trait。
2. **所有权模型**：Rust 的所有权模型确保了内存安全，不允许悬挂指针或者未定义的行为。`Box<T>` 是 Rust 的一种堆分配方式，它拥有一个指向堆上数据的指针，并且遵循 Rust 的所有权规则。

当你使用 `Box::new` 来创建一个新的 `Box<dyn Trait>` 时，你实际上是在堆上分配了一个新的对象，并返回了一个指向它的 `Box`。这样做的好处包括：

- **封装性**：`Box<dyn Trait>` 封装了具体的类型，使得你可以在不知道具体类型的情况下使用它。
- **安全性**：通过 `Box`，Rust 可以确保堆上的值在不再使用时被正确地清理，避免内存泄露。
- **多态性**：`Box<dyn Trait>` 允许你在运行时切换不同的具体实现，这是多态性的一种形式。

如果你尝试将多个实现相同 trait 的不同类型直接向上推导为 `dyn Trait`，Rust 的编译器会因为无法确定具体类型而报错。使用 `Box::new` 是一种显式地告诉编译器你想要创建一个堆上的新对象，并且你希望这个对象被视为一个实现了特定 trait 的类型。

总结一下，Rust 中的 `Box<dyn Trait>` 是一种安全的、能够在编译时提供静态类型保证的多态性机制。

